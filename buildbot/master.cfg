# -*- python -*-
# ex: set syntax=python:
# vim:ft=python

import json
import os

def _path(name):
    return os.path.join(os.path.dirname(__file__), name)

# This is a buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

# Master variable to toggle config between testing on your personal system
# (where /opt/local shouldn't be messed with) and the production server (where
# it has to be)

production   = False
privkey      = ''
slaveport    = 9989
httpport     = 8010
buildboturl  = "http://localhost:8010/"
htpasswdfile = "htpasswd"
mpbbsvnurl   = "https://svn.macports.org/repository/macports/contrib/mp-buildbot"
svnurl       = "https://svn.macports.org/repository/macports/trunk"
archivesite  = "http://packages.macports.org"
slaveprefix  = "/opt/local"
toolsprefix  = "/opt/mports"

if os.path.exists(_path('config.json')):
    with open(_path('config.json')) as f:
        configdata = json.load(f)
    locals = locals()
    for key in ["production", "privkey", "slaveport", "httpport", "buildboturl", "htpasswdfile", "mpbbsvnurl", "svnurl", "archivesite", "slaveprefix", "toolsprefix"]:
        if configdata[key]:
            locals[key] = configdata[key]

# TODO: the following list should be configured in slaves.json
build_platforms = ["10.6-x86_64"]
#build_platforms = ["snowleopard-x86_64", "lion-x86_64", "mtln-x86_64", "mavericks-x86_64", "yosemite-x86_64", "elcapitan-x86_64", "oelinux-6.3-x86_64"]

# Allow spaces and tabs in property values
import re
c['validation'] = {
    'property_value' : re.compile(r'^[ \t\w\.\-\/\~:]*$')
}

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave

c['slaves'] = []
slavedata = {}

with open(_path('slaves.json')) as f:
    slavedata = json.load(f)
for slave, pwd in slavedata.items():
    c['slaves'].append(BuildSlave(slave, pwd))


# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = slaveport

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

# poller is used for local testing but PBChangeSource (which relies on
# notifications from a post-commit script) should be used in production

if production:
    # TODO
    from buildbot.changes.pb import PBChangeSource
    sourcedata = []
#    with open(_path('source.json')) as f:
#        sourcedata = json.load(f)
#    c['change_source'] = PBChangeSource(user=sourcedata[0], passwd=sourcedata[1], port=sourcedata[2])
else:
    from buildbot.changes.svnpoller import SVNPoller
    c['change_source'] = (SVNPoller(
        svnurl='https://svn.macports.org/repository/macports/trunk',
        #'https://svn.macports.org/repository/macports/trunk',
        #svnbin='/opt/local/bin/svn',
        pollinterval=300,
        category='macports',
        project='ports'))

####### SCHEDULERS

def change_has_ports(change):
    for f in change.files:
        if "_resources" in f:
            continue
        # should actually skip changes to files/ only, but only if we know the
        # last build of the port succeeded
        if "dports" in f and ("Portfile" in f or "files" in f):
            return True
    return False

def change_has_base(change):
    for f in change.files:
        if f.startswith('base'):
            return True
    return False
        
from buildbot.changes.filter import ChangeFilter
portsfilter = ChangeFilter(filter_fn=change_has_ports)
basefilter = ChangeFilter(filter_fn=change_has_base)

base_buildernames = ["base-"+plat for plat in build_platforms]
portwatcher_buildernames = ["portwatcher-"+plat for plat in build_platforms if 'linux' not in plat]
portbuilder_buildernames = ["portbuilder-"+plat for plat in build_platforms if 'linux' not in plat]
portbuilder_triggerables = ["porttrigger-"+plat for plat in build_platforms if 'linux' not in plat]

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.schedulers.forcesched import StringParameter
from buildbot.schedulers.triggerable import Triggerable

c['schedulers'] = [SingleBranchScheduler(
                            name="base",
                            treeStableTimer=None,
                            change_filter = basefilter,
                            builderNames=base_buildernames),
                   SingleBranchScheduler(
                            name="ports",
                            treeStableTimer=None,
                            change_filter = portsfilter,
                            builderNames=portwatcher_buildernames),
                   ForceScheduler(
                            name="base_force",
                            builderNames=base_buildernames),
                   ForceScheduler(
                            name="portbuilder_force",
                            builderNames=portbuilder_buildernames,
                            properties=[
                                    StringParameter(
                                        name="portname",
                                        label="Port name:",
                                        default="")
                            ]),
                   ForceScheduler(
                            name="portwatcher_force",
                            builderNames=portwatcher_buildernames,
                            properties=[
                                    StringParameter(
                                        name="portlist",
                                        label="Port list:",
                                        default="",
                                        size=30)
                            ])
                ]

for i in range(len(portbuilder_buildernames)):
    c['schedulers'].append(Triggerable(name=portbuilder_triggerables[i],
                                       builderNames=[portbuilder_buildernames[i]]))

####### BUILDERS

# WARNING: mergeRequests has to be False or Triggerable builds will not be scheduled correctly!
c['mergeRequests'] = False

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory, GNUAutoconf
from buildbot.process.properties import WithProperties, Interpolate
from buildbot.steps.source.svn import SVN
from buildbot.steps.shell import ShellCommand, Compile, Configure, SetPropertyFromCommand

base_factory = BuildFactory()
base_factory.addStep(SVN(repourl='https://svn.macports.org/repository/macports/trunk/base',
#base_factory.addStep(SVN(repourl=Interpolate('https://svn.macports.org/repository/macports/%(src::branch:-trunk)s/base'),
                         method="copy"))
base_factory.addStep(Configure(command=WithProperties("""
env PATH=/usr/bin:/bin:/usr/sbin:/sbin ./configure --enable-readline \
    --prefix=%(workdir)s/opt/local \
    --with-applications-dir=%(workdir)s/opt/local/Applications \
    --with-install-user=`id -un` \
    --with-install-group=`id -gn` \
"""),logfiles={"config.log": "config.log"}))
base_factory.addStep(Compile(command="make -j`sysctl -n hw.activecpu`"))
base_factory.addStep(ShellCommand(command="make install", name="install", description="install"))
base_factory.addStep(ShellCommand(command="make test", name="test", description="test"))
base_factory.addStep(ShellCommand(command=WithProperties("make distclean; rm -rf %(workdir)s/opt/local"), 
                     name="clean", description="clean"))

# custom class to make the file list available on the slave...
class SetPropertyFromCommandWithPortlist(SetPropertyFromCommand):
         name = 'generate portlist'
         description = 'generate portlist'

         def setBuild(self, build):
            SetPropertyFromCommand.setBuild(self, build)
            
            portset = set()
            # support forced build properties
            if self.getProperty('portlist'):
                for v in self.getProperty('portlist').strip().split():
                    portset.add(v)

            # paths should be dports/category/portdir(/...)
            for f in self.build.allFiles():
                comps = f.split('/')
                if len(comps) >= 3 and comps[0] == 'dports' and comps[1] != '_resources':
                    portset.add(comps[2])

            self.setProperty('fullportlist', ' '.join(portset))


# can't run with prefix inside the workdir in production,
# because archives must be built with prefix=/opt/local
if production:
    prefix='/opt/local'
    dlhost='packages@packages-origin.macports.org'
    dlpath='/var/www/html/packages'
else:
    prefix=slaveprefix

    dlpath='./deployed_archives'
    dlhost=''

ulpath='archive_staging'
ulpath_unique=ulpath+'-%(buildername)s'

from buildbot.steps.transfer import DirectoryUpload
from buildbot.steps.master import MasterShellCommand
from buildbot.steps.trigger import Trigger

class TriggerWithPortlist(Trigger):
    def setTriggerTuple(self,t):
        self.triggertuple = t

    def getSchedulersAndProperties(self):
        sp = []
        for scheduler in self.schedulerNames:
            for port in self.build.getProperty("subportlist").split():
                sp.append([scheduler,{"portname": port}])
        return sp
        

# -- Port Watcher --

def make_portwatcher_factory(triggerable):
	portwatcher_factory = BuildFactory()
	# get mp-buildbot; we'll do the checkout of base and dports via these scripts
	portwatcher_factory.addStep(SVN(repourl=mpbbsvnurl,alwaysUseLatest=True,preferLastChangedRev=True,mode="incremental",workdir="build/mpbb",haltOnFailure=True))

	portwatcher_factory.addStep(SetPropertyFromCommandWithPortlist(command=WithProperties('for portname in %(fullportlist)s; do for subport in `./mpbb/tools/subports.tcl $portname`; do echo $subport; done; done' ),
								       property="subportlist",
                                         			       name="subports", description="subports"))

	portwatcher_factory.addStep(TriggerWithPortlist(schedulerNames=[triggerable],
							waitForFinish=True,
							updateSourceStamp=True))

	# make a logfile summarising the success/failure status for each port
	#portwatcher_factory.addStep(ShellCommand(command=["./do_status.sh"],
	#                                   name="status",
	#                                   description="status",
	#                        env={'PREFIX': WithProperties(prefix)
	#                             },
	#                        logfiles={"portstatus": "portstatus.log"}))

	return portwatcher_factory

from buildbot.process.buildstep import BuildStep

class InfoStep(BuildStep):
        def __init__(self, title='', **kwargs):
                BuildStep.__init__(self,**kwargs)
	        self.name = title
	        self.description = title
	        self.descriptionDone = title
                self.doStepIf = False

# -- Port Builder --

portbuilder_factory = BuildFactory()

# XXX: use InfoStep instead of running a dummy command
portbuilder_factory.addStep(ShellCommand(command=["/usr/bin/true"],descriptionDone=WithProperties("Port %(portname)s")))
#portbuilder_factory.addStep(InfoStep(title=WithProperties("Port %(portname)s")))

portbuilder_factory.addStep(SVN(repourl=mpbbsvnurl,alwaysUseLatest=True,preferLastChangedRev=True,mode="incremental",workdir="build/mpbb",haltOnFailure=True))
portbuilder_factory.addStep(ShellCommand(command=['./mpbb/mpbb', 'selfupdate', '--prefix', WithProperties(prefix)],haltOnFailure=True,
                                         name="selfupdate", description="selfupdate"))
portbuilder_factory.addStep(ShellCommand(command=['./mpbb/mpbb', 'checkout', '--prefix', WithProperties(prefix), '--svn-url', svnurl],
                                         timeout=3600,haltOnFailure=True,
                                         name="checkout", description="checkout"))
portbuilder_factory.addStep(ShellCommand(command=['./mpbb/mpbb', 'install-dependencies', '--prefix', WithProperties(prefix), '--port', WithProperties('%(portname)s')],haltOnFailure=True,
                                         name="install-dependencies", description="install-dependencies"))
portbuilder_factory.addStep(ShellCommand(command=['./mpbb/mpbb', 'install-port', '--prefix', WithProperties(prefix), '--port', WithProperties('%(portname)s')],haltOnFailure=True,
                                         name="install-port", description="install-port"))
portbuilder_factory.addStep(ShellCommand(command=['./mpbb/mpbb', 'gather-archives', '--prefix', WithProperties(prefix), '--port', WithProperties('%(portname)s'), '--archive-site', archivesite, '--staging-dir', ulpath],haltOnFailure=True,
                                         name="gather-archives", description="gather-archives"))

# upload archives from build slave to master
portbuilder_factory.addStep(DirectoryUpload(slavesrc=ulpath, masterdest=WithProperties(ulpath_unique)))

# XXX: move deploy_archives.sh functionality to mp-buildbot
# sign generated binaries and sync to download server (if distributable)
#if production:
#    portbuilder_factory.addStep(MasterShellCommand(command=["./deploy_archives.sh", WithProperties(ulpath_unique)],
#                                       name="deploy archives",
#                                       description="deploy archives",
#                          env={'PRIVKEY': privkey,
#                               'DLHOST': dlhost,
#                               'DLPATH': dlpath}))

# TODO: do we want to upload the individual logs so maintainers can review them?
#ports_factory.addStep(ShellCommand(command="./cleanup_old.sh",
#                                   name="cleanup",
#                                   description="cleanup",
#                                   env={'PREFIX': WithProperties(prefix),
#                                        'ULPATH': ulpath}))

# === BUILDER CONFIGURATION ===

from buildbot.config import BuilderConfig

# XXX: slavenames assignment should be automatic and more generic
portsslaves = {}
baseslaves = {}
if production:
    slavenames = slavedata.keys()
    for plat in build_platforms:
        baseslaves[plat] = filter(lambda x: x.endswith(plat+"-base"), slavenames)
        portsslaves[plat] = filter(lambda x: x.endswith(plat+"-ports"), slavenames)
#else:
    #slavenames = ["snowleopard-x86_64"]
    #slavenames = ["base-10.6-x86_64","10.6-x86_64","10.9-x86_64"]
    #portsslaves = {build_platforms[0]:slavenames[0],build_platforms[1]:slavenames[1]}
    #baseslaves = {build_platforms[0]:slavenames[0],build_platforms[1]:slavenames[1]}

c['builders']=[]
for plat in build_platforms:
    c['builders'] += [BuilderConfig(
        name="base-" + plat,
        slavenames=["base-" + plat],
        factory=base_factory,
        env={"PATH": "/usr/bin:/bin:/usr/sbin:/sbin"})] 
    if 'linux' not in plat: 
        c['builders'] += [
            BuilderConfig(
                name="portwatcher-" + plat,
                slavenames=["ports-" + plat],
                factory=make_portwatcher_factory("porttrigger-" + plat),
                env={"PATH": "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"}),
            BuilderConfig(
                name="portbuilder-" + plat,
                slavenames=["ports-" + plat],
                factory=portbuilder_factory,
                env={"PATH": toolsprefix + "/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"})]

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import auth, authz

from buildbot.status.web.auth import HTPasswdAuth

# add new users with crypt, not md5/sha1:
# htpasswd -d -n $USER
htauth = HTPasswdAuth(htpasswdfile)

authz_cfg=authz.Authz(
    auth=htauth,
    gracefulShutdown = 'auth',
    forceBuild = 'auth',
    forceAllBuilds = 'auth',
    pingBuilder = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)

if production:
    # send mail about base failures to users on the blamelist
    from buildbot.status.mail import MailNotifier
    mn = MailNotifier(fromaddr="noreply@macports.org", lookup="", relayhost="localhost",
        builders=base_buildernames, mode="problem")
    c['status'].append(mn)

    import subprocess
    from twisted.internet import defer
    # notifier that sends mail to last committers and maintainers of failed ports
    class PortsMailNotifier(MailNotifier):
        # would make more sense to override getInterestedUsers() in BuildStatus,
        # but it seems almost impossible to tell a builder to use a different
        # class for status in its Build objects
        def useLookup(self, build):
            failedPorts = set()
            interestedUsers = set()

            # XXX: needs to be rewritten for the new steps of mp-buildbot
            statusStep = [x for x in build.getSteps() if x.getName() == "status"][0]
            statusLog = [x for x in statusStep.getLogs() if x.getName() == "portstatus"][0]
            for line in statusLog.getText().splitlines():
                halves = line.split()
                if halves[0] == "[FAIL]":
                    failedPorts.add(halves[1])

            for p in failedPorts:
                output = subprocess.Popen(['/opt/local/bin/port', 'info', '--index', '--maintainers', '--line', p], stdout=subprocess.PIPE).communicate()[0].strip()
                for m in output.split(','):
                    if m != "nomaintainer@macports.org" and m != "openmaintainer@macports.org":
                        interestedUsers.add(m)

            ss = build.getSourceStamp()
            if ss:
                for c in ss.changes:
                    interesting = False
                    for f in c.files:
                        comps = f.split('/')
                        if len(comps) >= 3 and comps[2] in failedPorts and comps[0] == 'dports' and comps[1] != '_resources':
                            interesting = True
                            break
                    if interesting:
                        interestedUsers.add(c.who)

            dl = []
            for u in interestedUsers:
                d = defer.maybeDeferred(self.lookup.getAddress, u)
                dl.append(d)
            return defer.gatherResults(dl)

    mn = PortsMailNotifier(fromaddr="noreply@macports.org", lookup="", relayhost="localhost",
        builders=ports_buildernames, mode="failing")
    c['status'].append(mn)

####### PROJECT IDENTITY

from buildbot.plugins import util

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "MacPorts"
c['titleURL'] = "http://www.macports.org/"

c['buildbotURL'] = buildboturl
c['status'].append(html.WebStatus(
        http_port=httpport,
        authz=authz_cfg,
        changecommentlink=(r"#(\d+)", r"https://trac.macports.org/ticket/\1", r"Ticket \g<0>")
    ))

c['revlink'] = util.RevlinkMatch([r'https://svn.macports.org/repository/macports/(.*)'],
                                  r'https://trac.macports.org/changeset/%s')


####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}


######## Cache settings
c['buildHorizon'] = 10000
c['logHorizon'] = 5000
c['eventHorizon'] = 2000
c['buildCacheSize'] = 600

